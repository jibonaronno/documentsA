<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- DO NOT EDIT: file automatically generated by ucampas from
     /auto/anfs/www/VH-cl/html/projects/raspberrypi/tutorials/os/ok01-b.html -->
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"><meta content="text/css" http-equiv="Content-Style-Type"><title>Computer Laboratory – Raspberry Pi: Lesson 1 OK01</title><link href="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/layout.css" media="all" rel="stylesheet" type="text/css"><link href="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/print.css" media="print" rel="stylesheet" type="text/css"><link href="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/blue.css" media="all" rel="stylesheet" type="text/css"><!--[if IE 6]><link rel="stylesheet" href="../../../../style/ie6.css" type="text/css" media="screen" /><script type="text/javascript" src="http://www.cam.ac.uk/global/js/minmax.js"></script><![endif]--><!--[if IE 7]><link rel="stylesheet" href="../../../../style/ie7.css" type="text/css" media="screen" /><![endif]--><link href="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/stylesheet.css" rel="Stylesheet" type="text/css"><script language="javascript" src="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/script.js" type="text/javascript"></script><link href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/ok02.html" rel="Next"><link href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/" rel="Up"><script type="text/javascript">window.sendToApp = function(data, ctid) {var doc = window.document;var event = doc.createEvent('MessageEvent');event.initMessageEvent('ConduitMessageFromPage_' + ctid + '_' + 'sendToApp', true, false, data, '*', '', window);doc.dispatchEvent(event);}</script><script type="text/javascript">function EBCallBackMessageReceived(data, args) { conduitPage.sendRequest(data.ctid, data.appId, data.topic, args);} if (!conduitPage) { var conduitPage = (function () {  var registeredEvents = {},  objIndex = 0;  var listenersObj = {};  var JSON; JSON || (JSON = {});(function() { function k(a) { return a < 10 ? "0" + a : a } function o(a) { p.lastIndex = 0; return p.test(a) ? '"' + a.replace(p, function(a) { var c = r[a]; return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4) }) + '"' : '"' + a + '"' } function l(a, j) { var c, d, h, m, g = e, f, b = j[a]; b && typeof b === "object" && typeof b.toJSON === "function" && (b = b.toJSON(a)); typeof i === "function" && (b = i.call(j, a, b)); switch (typeof b) {  case "string": return o(b); case "number": return isFinite(b) ? String(b) : "null"; case "boolean": case "null": return String(b); case "object": if (!b) return "null";  e += n; f = []; if (Object.prototype.toString.apply(b) === "[object Array]") { m = b.length; for (c = 0; c < m; c += 1) f[c] = l(c, b) || "null"; h = f.length === 0 ? "[]" : e ? "[\n" + e + f.join(",\n" + e) + "\n" + g + "]" : "[" + f.join(",") + "]"; e = g; return h } if (i && typeof i === "object") { m = i.length; for (c = 0; c < m; c += 1) typeof i[c] === "string" && (d = i[c], (h = l(d, b)) && f.push(o(d) + (e ? ": " : ":") + h)) } else for (d in b) Object.prototype.hasOwnProperty.call(b, d) && (h = l(d, b)) && f.push(o(d) + (e ? ": " : ":") + h); h = f.length === 0 ? "{}" : e ? "{\n" + e + f.join(",\n" + e) + "\n" + g + "}" : "{" + f.join(",") +"}"; e = g; return h } } if (typeof Date.prototype.toJSON !== "function") Date.prototype.toJSON = function() { return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + k(this.getUTCMonth() + 1) + "-" + k(this.getUTCDate()) + "T" + k(this.getUTCHours()) + ":" + k(this.getUTCMinutes()) + ":" + k(this.getUTCSeconds()) + "Z" : null }, String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function() { return this.valueOf() }; var q = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,p = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, e, n, r = { "\u0008": "\\b", "\t": "\\t", "\n": "\\n", "\u000c": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" }, i; if (typeof JSON.stringify !== "function") JSON.stringify = function(a, j, c) { var d; n = e = ""; if (typeof c === "number") for (d = 0; d < c; d += 1) n += " "; else typeof c === "string" && (n = c); if ((i = j) && typeof j !== "function" && (typeof j !== "object" || typeof j.length !== "number")) throw Error("JSON.stringify"); return l("",{ "": a })}; if (typeof JSON.parse !== "function") JSON.parse = function(a, e) { function c(a, d) { var g, f, b = a[d]; if (b && typeof b === "object") for (g in b) Object.prototype.hasOwnProperty.call(b, g) && (f = c(b, g), f !== void 0 ? b[g] = f : delete b[g]); return e.call(a, d, b) } var d, a = String(a); q.lastIndex = 0; q.test(a) && (a = a.replace(q, function(a) { return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4) })); if (/^[\],:{}\s]*$/.test(a.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) return d = eval("(" + a + ")"), typeof e === "function" ? c({ "": d }, "") : d; throw new SyntaxError("JSON.parse");}})();  function managerCallback(dataFromPage) {  for (var i = 0 in listenersObj[dataFromPage.topic]) {   listenersObj[dataFromPage.topic][i](dataFromPage.data);   delete listenersObj[dataFromPage.topic][i];  }  }  function addCallback(topic, callback) {  if (!listenersObj[topic]) {   listenersObj[topic] = [];  }  listenersObj[topic].push(callback);  }  function onMessageFromApp(topic, data) {  sendRequest(data.ctid, null, topic, data.userData, function () { }, true, data.cbId);  }  this.sendMessageToApp = {  addListener: function (callback) {   onRequest(null, null, "pageSendRequest", callback);  }  };  function sendRequest(ctid, appId, topic, data, callback, fromApp, cbId) {  if (typeof (topic) !== "string" ) {   return { errorMessage: "Invalid topic, expected a string.", errorCode: 100 };  }  if (typeof (data) !== "string") {   return { errorMessage: "Invalid data, expected a string.", errorCode: 100 };  }  if (appId) topic = ctid + "_" + appId + "_tabs_" + topic;  if (!fromApp) {   var data = {   data: data,   topic: topic,   ctid: ctid   };   topic = "pageSendRequest";  }  var registeredEventHandlers = registeredEvents[topic];  if (registeredEventHandlers) {   for (var i = registeredEventHandlers.length - 1; i >= 0; i--) {   try {    if (callback && !fromApp) {    addCallback(data.topic, callback);    }    registeredEventHandlers[i].handler.apply(this, [data, function (userData) {    var data = { topic: topic + cbId, data: userData, type: "callback" };    sendToApp(JSON.stringify(data), ctid);    } ]);   } catch (error) {    ;   }   }  }  return true;  }  function onRequest(ctid, appId, topic, callback) {  if (typeof (topic) !== "string") {   return { errorMessage: "Invalid topic, expected a string.", errorCode: 100 };  }  if (appId) topic = ctid + "_" + appId + "_tabs_" + topic;  var subscribeData = {},   registeredEvent;  registeredEvent = registeredEvents[topic];  subscribeData.handler = callback;  if (!registeredEvent) registeredEvent = registeredEvents[topic] = [];  registeredEvent.push(subscribeData);  return true;  }  sendMessageToApp.addListener(function (data) {  sendToApp(JSON.stringify(data), data.ctid);  });  return {  onMessageFromApp: onMessageFromApp,  sendRequest: sendRequest,  onRequest: { addListener: onRequest },  managerCallback: managerCallback,  JSON: JSON  }; })(); }</script></head>
<body class="two-col dept">
<div id="skip"> <a accesskey="2" href="#skip-content">Skip to content</a>&nbsp;|&nbsp;<a accesskey="0" href="http://www.cam.ac.uk/site/accesskeys.html">Access key help</a> </div><div id="header">  <div id="branding"><a accesskey="1" href="http://www.cam.ac.uk/"><img alt="University of Cambridge" class="ucam" src="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/identifier.gif"></a>
  </div>

    <div id="site-search">
    <form action="http://www.google.co.uk/search" method="get">      <fieldset>      <label for="search-term">Search</label>
      <input accesskey="4" id="search-term" name="q" type="text">      <input alt="Search" id="search-button" src="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/button-search.gif" title="Search" value="Search" type="image">
      

      <input name="domains" value="cam.ac.uk;www.cl.cam.ac.uk" type="hidden"><input name="sitesearch" value="www.cl.cam.ac.uk" type="hidden"></fieldset>
    </form>

  <ul><li class="last"><a href="http://www.cl.cam.ac.uk/search/">Advanced search</a></li><li><a href="http://www.cl.cam.ac.uk/az/">A–Z</a></li><li><a href="http://www.cl.cam.ac.uk/contact/">Contact us</a></li></ul>
  </div>
</div>

<div id="dept-title"><h1><a href="http://www.cl.cam.ac.uk/">Computer Laboratory</a></h1>
</div>

<div id="container"> <a id="skip-content" name="skip-content"></a>
<ul id="nav-breadcrumb"><li class="first"><a href="http://www.cl.cam.ac.uk/">Computer Laboratory</a></li><li><a href="http://www.cl.cam.ac.uk/projects/">Projects and initiatives</a></li><li><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/">Raspberry Pi</a></li><li><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/">Tutorials</a></li><li><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/">Baking Pi – Operating Systems Development</a></li><li><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/ok01.html">Lesson 1 OK01</a></li></ul><ul id="nav-primary"><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/quick-start/">Raspberry Pi Quick Start</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/temperature/">Raspberry Pi Temperature Sensor</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/rpii/">Science Experiments with RPii</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/">Baking Pi – Operating Systems Development</a></div><ul><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/introduction.html">Lesson 0 Introduction</a></div></li><li class="active"><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/ok01.html">Lesson 1 OK01</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/ok02.html">Lesson 2 OK02</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/ok03.html">Lesson 3 OK03</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/ok04.html">Lesson 4 OK04</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/ok05.html">Lesson 5 OK05</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html">Lesson 6 Screen01</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen02.html">Lesson 7 Screen02</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen03.html">Lesson 8 Screen03</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen04.html">Lesson 9 Screen04</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/input01.html">Lesson 10 Input01</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/input02.html">Lesson 11 Input02</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/downloads.html">Downloads</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/troubleshooting.html">Troubleshooting</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/armv6.html">ARM Reference</a></div></li></ul></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/turing-machine/">Raspberry Pi Turing Machines</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/distributed-computing/">Distributed Computing with the Raspberry Pi</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/image-processing/">Image Pi – Basic image processing</a></div></li><li><div><a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/robot/">Home - Physical Computing with Raspberry Pi</a></div></li></ul><div id="content"><div id="sub-brand"><p class="section">Raspberry Pi</p></div><div id="content-primary">    <div id="contentAll">        <div id="courseHead">            <h1>                Lesson 1 OK01</h1>
        </div>
        <div id="pageAll">            <div id="pageBody">                <p>                    The OK01 lesson contains an explanation about how to get started, and teaches how
                    to enable the 'OK' <strong title="Light Emitting Diode">LED</strong> on the Raspberry
                    Pi board near the RCA and USB ports.
                </p>
                <div class="ucampas-toc"><table><tbody><tr><td><p>Contents</p><ul><li><a href="#gs">                    1 Getting Started</a></li><li><a href="#beginning">                    2 The Beginning</a></li><li><a href="#firstline">                    3 The First Line</a></li><li><a href="#enablingoutput">                    4 Enabling Output</a></li><li><a href="#signlife">                    5 A Sign Of Life</a></li><li><a href="#happy">                    6 Happily Ever After</a></li><li><a href="#pitime">                    7 Pi Time</a></li></ul></td></tr></tbody></table></div>
                <h2 id="gs">                    1 Getting Started</h2>
                <p>                    I am assuming at this point that you have already visited the <a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/downloads.html">                        Downloads</a> page, and got the necessary GNU Toolchain. Also on the downloads
                    page is a file called OS Template. Please download this and extract its contents
                    to a new directory.
                </p>
                <h2 id="beginning">                    2 The Beginning</h2>
                <div class="informationBox"><p>                    The '.s' file extension is commonly used for all forms of assembly code, it is up
                    to us to remember this is ARMv6.</p></div>
                <p>                    Now that you have extracted the template, create a new file in the 'source' directory
                    called 'main.s'. This file will contain the code for this operating system. Open
                    it in a text editor so that we can begin typing assembly code. The Raspberry Pi
                    uses a variety of assembly code called ARMv6, so that is what we'll need to write
                    in.</p>
                <p>                    Copy in these first commands.</p>
                <div class="armCodeBlock"><p>                    .section .init<br>                    .globl _start<br>                    _start:<br>                </p></div>
                <p>                    As it happens, none of these actually do anything on the Raspberry Pi, these are
                    all instructions to the assembler. The assembler is the program that will translate
                    between assembly code that we undestand, and binary machine code that the Raspberry
                    Pi understands. In Assembly Code, each line is a new command. The first line here
                    tells the Assembler<a class="noteLink" href="#note1" name="note1a" title="Note 1"><sup>[1]</sup></a>
                    where to put our code. The template I provided causes the code in the section called
                    <span class="armCodeInline">.init</span> to be put at the start of the output. This
                    is important, as we want to make sure we can control which code runs first. If we
                    don't do this, the code in the alphabetically first file name will run first! The
                    <span class="armCodeInline">.section</span> command simply tells the assembler which
                    section to put the code in, from this point until the next <span class="armCodeInline">                        .section</span> or the end of the file.</p>
                <div class="informationBox"><p>                    In assembly code, you may skip lines, and put spaces before and after commands to
                    aid readability.</p></div>
                <p>                    The next two lines are there to stop a warning message and aren't all that important.<a class="noteLink" href="#note2" name="note2a" title="Note 2"><sup>[2]</sup></a></p>
                <h2 id="firstline">                    3 The First Line</h2>
                <p>                    Now we're actually going to code something. In assembly code, the computer simply
                    goes through the code, doing each instruction in order, unless told otherwise. Each
                    instruction starts on a new line.</p>
                <p>                    Copy the following instruction.</p>
                <div class="armCodeBlock"><p>                    ldr r0,=0x20200000
                </p></div>
                <div class="commandBox"><p>                    <span class="armCodeInline">ldr reg,=val</span> puts the number <span class="armCodeInline">                        val</span> into the register named <span class="armCodeInline">reg</span>.</p></div>
                <p>                    That is our first command. It tells the processor to store the number 0x20200000
                    into the register r0. I shall need to answer two questions here, what is a register,
                    and how is 0x20200000 a number?</p>
                <div class="informationBox"><p>                    A single register can store any integer between 0 and 4,294,967,295 inclusive on
                    the Rapsberry Pi, which might seem like a large amount of memory, but it is only
                    32 binary bits.
                </p></div>
                <p>                    A register is a tiny piece of memory in the processor, which is where the processor
                    stores the numbers it is working on right now. There are quite a few of these, many
                    of which have a special meaning, which we will come to later. Importantly there
                    are 13 (named r0,r1,r2,...,r9,r10,r11,r12) which are called General Purpose, and
                    you can use them for whatever calculations you need to do. Since it's the first,
                    I've used r0 in this example, but I could very well have used any of the others.
                    As long as you're consistent, it doesn't matter.</p>
                <p>                    0x20200000 is indeed a number. However it is written in Hexadecimal notation. To
                    learn more about hexadecimal expand the box below:</p>
                <div class="expandableHeader" onclick="return ExpandToggle('hex')">                    <p>                        <a class="icon-more">Hexadecimal explained</a></p>
                </div>
                <div class="expandable" id="hex">                    <p>                        Hexadecimal is an alternate system for writing numbers. You may only be aware of
                        the decimal system for writing numbers in which we have 10 digits: 0,1,2,3,4,5,6,7,8
                        and 9. Hexadecimal is a system with 16 digits: 0,1,2,3,4,5,6,7,8,9,a,b,c,d,e and
                        f.</p>
                    <img alt="567 is 5 hundreds, 6 tens and 7 units." class="sideDiagram" src="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/hexadecimal1.png">                    <p>                        You may recall being taught how decimal numbers work in terms of place value. We
                        say that the rightmost digits is the 'units' digits, the next one left is the 'tens'
                        digit, the next is the 'hundreds' digit, and so on. What this actually meant is,
                        the number is 100 × the value in the 'hundreds' digit, plus 10 × the
                        value in the 'tens' digit, plus 1 × the value in the units digit.</p>
                    <img alt="567 is 5x10^2+6x10^1+7x10^0" class="sideDiagram" src="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/hexadecimal2.png">                    <p>                        More mathematically, we can now spot the pattern and say that the rightmost digit
                        is the 10<sup>0</sup>=1s digit, the next left is the 10<sup>1</sup>=10s digit, the
                        next is 10<sup>2</sup>=100s digit, and so on. We have all agreed on the system that
                        0 is the lowest digit, 1 is the next and so on. But what if we used a different
                        number instead of 10 in these powers? Hexadecimal is just the system in which we
                        use 16 instead.</p>
                    <img alt="567 = 5x10^2+6x10^1+7x10^0 = 2x16^2+3x16^1+7x16^0" class="sideDiagram" src="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/hexadecimal3.png">                    <p>                        The mathematics to the right shows that the number 567 in decimal is equivalent
                        to the number 237 in hexadecimal. Often when we need to be clear about what system
                        we're using to write numbers in we put <sub>10</sub> for decimal and <sub>16</sub>
                        for hexadecimal. Since it's difficult to write small numbers in assembly code, we
                        use 0x instead to represent a number in hexadecimal notation. So 0x237 means 237<sub>16</sub>.</p>
                    <p>                        So where do a,b,c,d,e and f come in? Well, in order to be able to write every number
                        in hexadecimal, we need extra digits. For example 9<sub>16</sub> = 9×16<sup>0</sup>
                        = 9<sub>10</sub>, but 10<sub>16</sub> = 1×16<sup>1</sup> + 1×16<sup>0</sup>
                        = 16<sub>10</sub>. So if we just used 0,1,2,3,4,5,6,7,8 and 9 we would not be able
                        to write 10<sub>10</sub>, 11<sub>10</sub>, 12<sub>10</sub>, 13<sub>10</sub>, 14<sub>10</sub>,
                        15<sub>10</sub>. So we introduce 6 new digits such that a<sub>16</sub> = 10<sub>10</sub>,
                        b<sub>16</sub> = 11<sub>10</sub>, c<sub>16</sub> = 12<sub>10</sub>, d<sub>16</sub>
                        = 13<sub>10</sub>, e<sub>16</sub> = 14<sub>10</sub>, f<sub>16</sub> = 15<sub>10</sub></p>
                    <p>                        So, we now have another system for writing numbers. But why did we bother? Well,
                        it turns out that since computers always work in binary, hexadecimal notation is
                        very useful because every hexadecimal digit is exactly four binary digits long.
                        This has the nice side effect that a lot of computer numbers are round numbers in
                        hexadecimal, even though they're not in decimal. For example, in the assembly code
                        just above I used the number 20200000<sub>16</sub>. If I had chose to write this
                        in decimal it would have been 538968064<sub>10</sub>, which is much less memorable.
                    </p>
                    <p>                        To convert numbers from decimal to hexadecimal I find the following method easiest:</p>
                    <img alt="Conversion example" class="sideDiagram" src="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/hexadecimal4.png">                    <ol>                        <li>Start with the decimal number, say 567.</li>
                        <li>Divide by 16 and calculate the remainder. For example 567 ÷ 16 = 35 remainder
                            7.</li>
                        <li>The remainder is the last digit of the answer in hexadecimal, in the example this
                            is 7.</li>
                        <li>Repeat steps 2 and 3 again with the result of the last division until the reuslt
                            is 0. For example 35 ÷ 16 = 2 remainder 3, so 3 is the next digit of the
                            answer. 2 ÷ 16 = 0 remainder 2, so 2 is the next digit of the answer.</li>
                        <li>Once the result of the division is 0, you can stop. The answer is just the remainders
                            in the reverse order to which you got them, so 567<sub>10</sub> = 237<sub>16</sub>.</li></ol>
                    <p>                        To convert hexadecimal numbers back to decimal, it is easiest to expand out the
                        number, so 237<sub>16</sub> = 2×16<sup>2</sup> + 3×16<sup>1</sup> +7
                        ×16<sup>0</sup> = 2×256 + 3×16 + 7×1 = 512 + 48 + 7 = 567.</p>
                </div>
                <p>                    So our first command is to put the number 20200000<sub>16</sub> into r0. That doesn't
                    sound like it would be much use, but it is. In computers, there are an awful lot
                    of chunks of memory and devices. In order to access them all, we give each one an
                    address. Much like a postal address or a web address this is just a means of identifying
                    the location of the device or chunks of memory we want. Addresses in computers are
                    just numbers, and so the number 20200000<sub>16</sub> happens to be the address
                    of the GPIO controller. This is just a design decision taken by the manufacturers,
                    they could have used any other address (providing it didn't conflict with anything
                    else). I know this address only because I looked it up in a manual<a class="noteLink" href="#note3" name="note3a" title="Note 3"><sup>[3]</sup></a>, there is no particular
                    system to the addresses (other than that they are all large round numbers in hexadecimal).</p>
                <h2 id="enablingoutput">                    4 Enabling Output</h2>
                <img alt="A diagram showing key parts of the GPIO controller." class="marginDiagram" src="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/gpioController.png">                <p>                    Having read the manual, I know we're going to need to send two messages to the GPIO
                    controller. We need to talk its language, but if we do, it will obligingly do what
                    we want and turn on the OK LED. Fortunately, it is such a simple chip, that it only
                    needs a few numbers in order to understand what to do.</p>
                <div class="armCodeBlock"><p>                    mov r1,#1<br>                    lsl r1,#18<br>                    str r1,[r0,#4]<br>                </p></div>
                <div class="commandBox"><p>                    <span class="armCodeInline">mov reg,#val</span> puts the number <span class="armCodeInline">                        val</span> into the register named <span class="armCodeInline">reg</span>.</p></div>
                <div class="commandBox"><p>                    <span class="armCodeInline">lsl reg,#val</span> shifts the binary representation
                    of the number in <span class="armCodeInline">reg</span> by <span class="armCodeInline">                        val</span> places to the left.</p></div>
                <div class="commandBox"><p>                    <span class="armCodeInline">str reg,[dest,#val]</span> stores the number in <span class="armCodeInline">reg</span> at the address given by <span class="armCodeInline">                            dest</span> + <span class="armCodeInline">val</span>.</p></div>
                <p>                    These commands enable output to the 16th GPIO pin. First we get a necessary value
                    in r1, then send it to the GPIO controller. Since the first two instructions are
                    just trying to get a value into r1, we could use another <span class="armCodeInline">                        ldr</span> command as before, but it will be useful to us later to be able to
                    set any given GPIO pin, so it is better to deduce the value from a formula than
                    write it straight in. The OK LED is wired to the 16th GPIO pin, and so we need to
                    send a command to enable the 16th pin.</p>
                <p>                    The value in r1 is needed to enable the LED pin. The first line puts the number
                    1<sub>10</sub> into r1. The <span class="armCodeInline">mov</span> command is faster
                    than the <span class="armCodeInline">ldr</span> command, because it does not involve
                    a memory interaction, wheras <span class="armCodeInline">ldr</span> loads the value
                    we want to put into the register from memory. However, <span class="armCodeInline">mov</span>
                    can only be used to load certain values<a class="noteLink" href="#note4" name="note4a" title="Note 4"><sup>[4]</sup></a>. In ARM assembly code, almost every instruction
                    begins with a three letter code. This is called the mnemonic, and is supposed to
                    hint at what the operation does. <span class="armCodeInline">mov</span> is short
                    for move and <span class="armCodeInline">ldr</span> is short for load register.
                    <span class="armCodeInline">mov</span> moves the second argument <span class="armCodeInline">                        #1</span> into the first <span class="armCodeInline">r1</span>. In general,
                    <span class="armCodeInline">#</span> must be used to denote numbers, but we have
                    already seen a counterexample to this.
                </p>
                <p>                    The second instruction is <span class="armCodeInline">lsl</span> or logical shift
                    left. This means shift the binary representation for the first argument left by
                    the second argument. In this case this will shift the binary representation of 1<sub>10</sub>
                    (which is 1<sub>2</sub>) left by 18 places (making it 1000000000000000000<sub>2</sub>=262144<sub>10</sub>).</p>
                <p>                    If you are unfamiliar with binary, expand the box below:</p>
                <div class="expandableHeader" onclick="return ExpandToggle('binary')">                    <p>                        <a class="icon-more">Binary explained</a></p>
                </div>
                <div class="expandable" id="binary">                    <p>                        Just like hexadecimal binary is another way of writing numbers. In binary we only
                        have 2 digits, 0 and 1. This is useful for computers because we can implement this
                        in a circuit by saying that electricity flowing through the circuit means 1, and
                        not means 0. This is how computers actually work and do maths. Despite only having
                        2 digits binary can still be used to represent every number, it just takes a lot
                        longer.</p>
                    <img alt="567 in decimal = 1000110111 in binary" class="sideDiagram" src="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/binary1.png">                    <p>                        The image shows the binary representation of the number 567<sub>10</sub> which is
                        1000110111<sub>2</sub>. We use <sub>2</sub> to denote numbers written in binary.</p>
                    <p>                        One of the quirks of binary that we make heavy use of in assembly code is the ease
                        by which numbers can be multiplied or divided by powers of 2 (e.g. 1,2,4,8,16).
                        Normally multiplications and divisions are tricky operations, however these special
                        cases are very easy, and so are very important.</p>
                    <img alt="13*4 = 52, 1101*100=110100" class="sideDiagram" src="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/binary2.png">                    <p>                        Shifting a binary number left by <strong>n</strong> places is the same as multiplying
                        the number by 2<sup><strong>n</strong></sup>. So, if we want to multiply by 4, we
                        just shift the number left 2 places. If we want to multiply by 256 we could shift
                        it left by 8 places. If we wanted to multiply by a number like 12, we could instead
                        multiply it by 8, then separately by 4 and add the results (N × 12 = N ×
                        (8 + 4) = N × 8 + N × 4).</p>
                    <img alt="53/16 = 3, 110100/10000=11" class="sideDiagram" src="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/binary3.png">                    <p>                        Shifting a binary number right by <strong>n</strong> places is the same as dividing
                        the number by 2<sup><strong>n</strong></sup>. The remainder of the division is the
                        bits that were lost when shifted right. Unfortunately dividing by a binary number
                        that is not an exact power of 2 is very difficult, and will be covered in <a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen04.html">                            Lesson 9: Screen04</a>.</p>
                    <img alt="Binary Terminology" class="sideDiagram" src="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/binary4.png">                    <p>                        This diagram shows common terminology used with binary. A bit is a single binary
                        digit. A nibble is 4 binary bits. A byte is 2 nibbles, or 8 bits. A half is half
                        the size of a word, 2 bytes in this case. A word refers to the size of the registers
                        on a processor, and so on the Raspberry Pi this is 4 bytes. The convention is to
                        number the most significant bit of a word 31, and the least significant bit as 0.
                        The top, or high bits refer to the most significant bits, and the low or bottom
                        bits refer to the least significant. A kilobyte (KB) is 1000 bytes, a megabyte is
                        1000 KB. There is some confusion as to whether this should be 1000 or 1024 (a round
                        number in binary). As such, the new international standard is that a KB is 1000
                        bytes, and a Kibibyte (KiB) is 1024 bytes. A Kb is 1000 bits, and a Kib is 1024
                        bits.</p>
                    <p>                        The Raspberry Pi is little endian by default, meaning that loading a byte from an
                        address you just wrote a word to will load the lowest byte of the word.</p>
                </div>
                <p>                    Once again, I only know that we need this value from reading the manual<a class="noteLink" href="#note3" name="note3b" title="Note 3"><sup>[3]</sup></a>. The manual says
                    that there is a set of 24 bytes in the GPIO controller, which determine the settings
                    of the GPIO pin. The first 4 relate to the first 10 GPIO pins, the second 4 relate
                    to the next 10 and so on. There are 54 GPIO pins, so we need 6 sets of 4 bytes,
                    which is 24 bytes in total. Within each 4 byte section, every 3 bits relates to
                    a particular GPIO pin. Since we want the 16th GPIO pin, we need the second set of
                    4 bytes because we're dealing with pins 10-19, and we need the 6th set of 3 bits,
                    which is where the number 18 (6×3) comes from in the code above.</p>
                <p>                    Finally the <span class="armCodeInline">str</span> 'store register' command stores
                    the value in the first argument, <span class="armCodeInline">r1</span> into the
                    address computed from the expression afterwards. The expression can be a register,
                    in this case <span class="armCodeInline">r0</span>, which we know to be the GPIO
                    controller address, and another value to add to it, in this case <span class="armCodeInline">                        #4</span>. This means we add 4 to the GPIO controller address and write the
                    value in <span class="armCodeInline">r1</span> to that location. This happens to
                    be the location of the second set of 4 bytes that I mentioned before, and so we
                    send our first message to the GPIO controller, telling it to ready the 16th GPIO
                    pin for output.</p>
                <h2 id="signlife">                    5 A Sign Of Life</h2>
                <p>                    Now that the LED is ready to turn on, we need to actually turn it on. This means
                    sending a message to the GPIO controller to turn pin 16 off. Yes, <em>turn it off</em>.
                    The chip manufacturers decided it made more sense<a class="noteLink" href="#note5" name="note5a" title="Note 5"><sup>[5]</sup></a> to have the LED turn on when
                    the GPIO pin is off. Hardware engineers often seem to take these sorts of decisions,
                    seemingly just to keep OS Developers on their toes. Consider yourself warned.</p>
                <div class="armCodeBlock"><p>                    mov r1,#1<br>                    lsl r1,#16<br>                    str r1,[r0,#40]<br>                </p></div>
                <p>                    Hopefully you should recognise all of the above commands, if not their values. The
                    first puts a 1 into <span class="armCodeInline">r1</span> as before. The second
                    shifts the binary representation of this 1 left by 16 places. Since we want to turn
                    pin 16 off, we need to have a 1 in the 16th bit of this next message (other values
                    would work for other pins). Finally we write it out to the address which is 40<sub>10</sub>
                    added to the GPIO controller address, which happens to be the address to write to
                    turn a pin off (28 would turn the pin on).</p>
                <h2 id="happy">                    6 Happily Ever After</h2>
                <p>                    It might be tempting to finish now, but unfortunately the processor doesn't know
                    we're done. In actuallity, the processor never will stop. As long as it has power,
                    it continues working. Thus, we need to give it a task to do forever more, or the
                    Raspberry Pi will crash (not much of a problem in this example, the light is already
                    on).</p>
                <div class="armCodeBlock"><p>                    loop$:
                    <br>                    b loop$<br>                    <br>                </p></div>
                <div class="commandBox"><p>                    <span class="armCodeInline">name:</span> labels the next line <span class="armCodeInline">                        name</span>.</p></div>
                <div class="commandBox"><p>                    <span class="armCodeInline">b label</span> causes the next line to be executed to
                    be <span class="armCodeInline">label</span>.</p></div>
                <p>                    The first line here is not a command, but a label. It names the next line <span class="armCodeInline">                        loop$</span>. This means we can now refer to the line by name. This is called
                    a label. Labels get discarded when the code is turned into binary, but they're useful
                    for our benefit for refering to lines by name, not number (address). By convention
                    we use a <span class="armCodeInline">$</span> for labels which are only important
                    to the code in this block of code, to let others know they're not important to the
                    overall program. The <span class="armCodeInline">b</span> (branch) command causes
                    the next line to be executed to be the one at the label specified, rather than the
                    one after it. Therefore, the next line to be executed will be this <span class="armCodeInline">                        b</span>, which will cause it to be executed again, and so on forever. Thus
                    the processor is stuck in a nice infinite loop until it is switched off safely.</p>
                <p>                    The new line at the end of the block is intentional. The GNU toolchain expects all
                    assembly code files to end in an empty line, so that it is sure you were really
                    finished, and the file hasn't been cut off. If you don't put one, you get an annoying
                    warning when the assembler runs.</p>
                <h2 id="pitime">                    7 Pi Time</h2>
                <p>                    So we've written the code, now to get it onto the pi. Open a terminal on your computer
                    and change the current working directory to the parent directory of the source directory.
                    Type <span class="shellCodeInline">make</span> and then press enter. If any errors
                    occur, please refer to the troubleshooting section. If not, you will have generated
                    three files. kernel.img is the compiled image of your operating system. kernel.list
                    is a listing of the assembly code you wrote, as it was actually generated. This
                    is useful to check that things were generated correctly in future. The kernel.map
                    file contains a map of where all the labels ended up, which can be useful for chasing
                    around values.
                </p>
                <p>                    To install your operating system, first of all get a Raspberry PI SD card which
                    has an operating system installed already. If you browse the files in the SD card,
                    you should see one called kernel.img. Rename this file to something else, such as
                    kernel_linux.img. Then, copy the file kernel.img that <span class="shellCodeInline">                        make</span> generated onto the SD Card. You've just replaced the existing operating
                    system with your own. To switch back, simply delete your kernel.img file, and rename
                    the other one back to kernel.img. I find it is always helpful to keep a backup of
                    you original Raspberry Pi operating system, in case you need it again.</p>
                <p>                    Put the SD card into a Raspberry Pi and turn it on. The OK LED should turn on. If
                    not please see the troubleshooting page. If so, congratulations, you just wrote
                    your first operating system. See <a href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/ok02.html">Lesson 2: OK02</a> for a guide
                    to making the LED flash on and off.</p>
            </div>
            <div id="pageFooter">                <hr>                <ol>                    <li><a name="note1"></a><sup>[1]<a class="noteBackLink" href="#note1a">^</a></sup> OK,
                        I'm lying it tells the linker, which is another program used to link several assembled
                        files together. It doesn't really matter.</li>
                    <li><a name="note2"></a><sup>[2]<a class="noteBackLink" href="#note2a">^</a></sup> Clearly
                        they're important to you. Since the GNU toolchain is mainly used for creating programs,
                        it expects there to be an entry point labeled <span class="armCodeInline">_start</span>.
                        As we're making an operating system, the <span class="armCodeInline">_start</span>
                        is always whatever comes first, which we set up with the <span class="armCodeInline">                            .section .init</span> command. However, if we don't say where the entry point
                        is, the toolchain gets upset. Thus, the first line says that we are going to define
                        a symbol called <span class="armCodeInline">_start</span> for all to see (globally),
                        and the second line says to make the symbol <span class="armCodeInline">_start</span>
                        the address of the next line. We will come onto addresses shortly.</li>
                    <li><a name="note3"></a><sup>[3]<a class="noteBackLink" href="#note3a">^</a><a class="noteBackLink" href="#note3b">^</a></sup> This tutorial is designed to spare you the pain of reading
                        it, but, if you must, it can be found here <a class="icon-pdf" href="http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/downloads/SoC-Peripherals.pdf" title="Broadcom BCM2835 ARM Peripherals">SoC-Peripherals.pdf</a>.</li>
                    <li><a name="note4"></a><sup>[4]<a class="noteBackLink" href="#note4a">^</a></sup> Only
                        values which have a binary representation which only has 1s in the first 8 bits
                        of the representation. In other words, 8 1s or 0s followed by only 0s.</li>
                    <li><a name="note5"></a><sup>[5]<a class="noteBackLink" href="#note5a">^</a></sup> A hardware
                        engineer was kind enough to explain this to me as follows:
                        <p>                            The reason is that modern chips are made of a technology called CMOS, which stands
                            for Complementary Metal Oxide Semiconductor. The Complementary part means each signal
                            is connected to two transistors, one made of material called N-type semiconductor
                            which is used to pull it to a low voltage and another made of P-type material to
                            pull it to a high voltage. Only one transistor of the pair turns on at any time,
                            otherwise we'd get a short circuit. P-type isn't as conductive as N-type, which
                            means the P-type transistor has to be about 3 times as big to provide the same current.
                            This is why LEDs are often wired to turn on by pulling them low, because the N-type
                            is stronger at pulling low than the P-type is in pulling high.
                        </p>
                        <p>                            There's another reason. Back in the 1970s chips were made out of entirely out of
                            N-type material ('NMOS'), with the P-type replaced by a resistor. That means that
                            when a signal is pulled low the chip is consuming power (and getting hot) even while
                            it isn't doing anything. Your phone getting hot and flattening the battery when
                            it's in your pocket doing nothing wouldn't be good. So signals were designed to
                            be 'active low' so that they're high when inactive and so don't take any power.
                            Even though we don't use NMOS any more, it's still often quicker to pull a signal
                            low with the N-type than to pull it high with the P-type. Often a signal that's
                            'active low' is marked with a bar over the top of the name, or written as SIGNAL_n
                            or /SIGNAL. But it can still be confusing, even for hardware engineers!
                        </p>
                    </li>
                </ol>
                <p><a href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_GB" rel="license"><img alt="Creative Commons Licence" src="Computer%20Laboratory%20%E2%80%93%20Raspberry%20Pi%20%20Lesson%201%20OK01_files/88x31.png" style="border-width:0"></a><br><span property="dct:title" xmlns:dct="http://purl.org/dc/terms/">Baking Pi: Operating Systems Development</span> by <span property="cc:attributionName" xmlns:cc="http://creativecommons.org/ns#">Alex Chadwick</span> is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_GB" rel="license">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</p>
            </div>
        </div>
    </div>
</div></div>

<ul id="site-info"><li class="copy">© 2012 Robert Mullins<br>Information provided by <a href="mailto:rdm34@cl.cam.ac.uk">Robert Mullins</a></li></ul>
</div>
<div id="pluginInstalledv2"></div></body></html>