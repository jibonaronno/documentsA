#include "qFilterIIR_HP02.h"

/*
 * Filter Coefficients (C Source) generated by the Filter Design and Analysis Tool
 * Generated by MATLAB(R) 9.5 and Signal Processing Toolbox 8.1.
 * Generated on: 11-Jan-2019 14:30:07
 */

/*
 * Discrete-Time IIR Filter (real)
 * -------------------------------
 * Filter Structure    : Direct-Form I, Second-Order Sections
 * Number of Sections  : 2
 * Stable              : Yes
 * Linear Phase        : No
 */

#ifdef USE_BUTTERWORTH_0_2HZ_1ST_ORDER
static const int NL[MWSPT_NSEC] = { 1,2,1 };
static const double NUM[MWSPT_NSEC][2] = {
  {
     0.9987449394335,                 0
  },
  {
                   1,                -1
  },
  {
                   1,                 0
  }
};
static const int DL[MWSPT_NSEC] = { 1,2,1 };
static const double DEN[MWSPT_NSEC][2] = {
  {
                   1,                 0
  },
  {
                   1,  -0.9974898788671
  },
  {
                   1,                 0
  }
};
#else
static const int NL[MWSPT_NSEC] = { 1,3,1 };
static const double NUM[MWSPT_NSEC][3] = {
  {
     0.9991931994437,                 0,                 0
  },
  {
                   1,   -1.999996841726,                 1
  },
  {
                   1,                 0,                 0
  }
};
static const int DL[MWSPT_NSEC] = { 1,3,1 };
static const double DEN[MWSPT_NSEC][3] = {
  {
                   1,                 0,                 0
  },
  {
                   1,   -1.998382592234,   0.9983870498152
  },
  {
                   1,                 0,                 0
  }
};
#endif

qFilterIIR_HP02::qFilterIIR_HP02() :
    qAbstractFilter (0)
{
    privInit();
}

void qFilterIIR_HP02::InitLead(int lead)
{
    for(int i=0; i<MWSPT_NSEC; i++) {
        x[lead][i][0] = 0;
        x[lead][i][1] = 0;
        x[lead][i][2] = 0;
        y[lead][i][0] = 0;
        y[lead][i][1] = 0;
        y[lead][i][2] = 0;
    }
}

void qFilterIIR_HP02::privInit()
{
    memset(x, 0, sizeof(x));
    memset(y, 0, sizeof(y));
}

int32_t qFilterIIR_HP02::privFilter(int32_t sample, int lead)
{
#if 0
    uint16_t i;
    x[lead][0][0] = sample;
    for(i=0; i<MWSPT_NSEC; i++) {
        y[lead][i][0] =
                x[lead][i][0] * NUM[i][0] +
                x[lead][i][1] * NUM[i][1] +
                x[lead][i][2] * NUM[i][2] -
                y[lead][i][1] * DEN[i][1] -
                y[lead][i][2] * DEN[i][2];

        y[lead][i][0] /= DEN[i][0];

        y[lead][i][2]=y[lead][i][1]; y[lead][i][1]=y[lead][i][0];
        x[lead][i][2]=x[lead][i][1]; x[lead][i][1]=x[lead][i][0];

        x[lead][i+1][0] = y[lead][i][0];
    }
    if( x[lead][MWSPT_NSEC][0] > 32767)  x[lead][MWSPT_NSEC][0] = 32767;
    if( x[lead][MWSPT_NSEC][0] < -32768) x[lead][MWSPT_NSEC][0] = -32768;
    return  static_cast<int32_t>(x[lead][MWSPT_NSEC][0]);
#else
    double w = sample;
    for(int i=0; i < MWSPT_NSEC; i++) {
        x[lead][i][2] = x[lead][i][1];
        x[lead][i][1] = x[lead][i][0];
        x[lead][i][0] = w;
        w=0;
        y[lead][i][2] = y[lead][i][1];
        y[lead][i][1] = y[lead][i][0];
        for ( int j=0; j<NL[i]; j++ )
            w += NUM[i][j] * x[lead][i][j];
        for ( int j=1; j<DL[i]; j++ )
            w -= DEN[i][j] * y[lead][i][j];
        w /= DEN[i][0];
        y[lead][i][0] = w;
    }
    return static_cast<int32_t>(w);
#endif
}
