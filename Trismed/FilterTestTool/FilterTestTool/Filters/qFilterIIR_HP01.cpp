#include "qFilterIIR_HP01.h"
/*
 * Filter Coefficients (C Source) generated by the Filter Design and Analysis Tool
 * Generated by MATLAB(R) 9.5 and Signal Processing Toolbox 8.1.
 * Generated on: 21-Dec-2018 13:44:20
 */

/*
 * Discrete-Time IIR Filter (real)
 * -------------------------------
 * Filter Structure    : Direct-Form I, Second-Order Sections
 * Number of Sections  : 1
 * Stable              : Yes
 * Linear Phase        : No
 */

#ifdef USE_CUSTOM
qFilterIIR_HP01::qFilterIIR_HP01() :
    qAbstractFilter(0)
{
    privInit();
}

void qFilterIIR_HP01::InitLead(int lead)
{
    privInit();
}

void qFilterIIR_HP01::privInit()
{
    inPos = 0;
    outPos = DELAY-1;
    memset(buff, 0, sizeof(int32_t)*DELAY*AMP_IN_LEADS);
    memset(cummul, 0, sizeof(int32_t)*AMP_IN_LEADS);
}

int32_t qFilterIIR_HP01::privFilter(int32_t sample, int lead)
{
    double result;
    cummul[lead]-=buff[lead][inPos];
    cummul[lead]+=sample;
    avg[lead]=(avg[lead]+cummul[lead]/DELAY)/2;
    buff[lead][inPos] = sample;
    inPos++;
    if(inPos>=DELAY)inPos=0;

    result = buff[lead][outPos]-avg[lead];
    outPos++;
    if(outPos>=DELAY)outPos=0;

    return static_cast<int32_t>(result);
}
#else
#ifdef USE_BUTTERWORTH_0_1HZ_1ST_ORDER
static const int NL[MWSPT_NSEC] = { 1,2,1 };
static const double NUM[MWSPT_NSEC][2] = {
  {
      0.999372075923,                 0
  },
  {
                   1,                -1
  },
  {
                   1,                 0
  }
};
static const int DL[MWSPT_NSEC] = { 1,2,1 };
static const double DEN[MWSPT_NSEC][2] = {
  {
                   1,                 0
  },
  {
                   1,   -0.998744151846
  },
  {
                   1,                 0
  }
};
#else
static const int NL[MWSPT_NSEC] = { 1,3,1 };
static const double NUM[MWSPT_NSEC][3] = {
    {
        0.9995965182108,                 0,                 0
    },
    {
        1,   -1.999999210432,                 1
    },
    {
        1,                 0,                 0
    }
};
static const int DL[MWSPT_NSEC] = { 1,3,1 };
static const double DEN[MWSPT_NSEC][3] = {
    {
        1,                 0,                 0
    },
    {
        1,   -1.999192084374,   0.9991931992192
    },
    {
        1,                 0,                 0
    }
};
#endif

qFilterIIR_HP01::qFilterIIR_HP01() :
    qAbstractFilter(0)
{
    privInit();
}

void qFilterIIR_HP01::InitLead(int lead)
{
    for(int i=0; i<MWSPT_NSEC; i++) {
        x[lead][i][0] = 0;
        x[lead][i][1] = 0;
        x[lead][i][2] = 0;
        y[lead][i][0] = 0;
        y[lead][i][1] = 0;
        y[lead][i][2] = 0;
    }
}

void qFilterIIR_HP01::privInit()
{
    memset(x, 0, sizeof(x));
    memset(y, 0, sizeof(y));
}

int32_t qFilterIIR_HP01::privFilter(int32_t sample, int lead)
{
#if 0
    uint16_t i;
    x[lead][0][0] = sample;
    for(i=0; i<MWSPT_NSEC; i++) {
        y[lead][i][0] =
                x[lead][i][0] * NUM[i][0] +
                x[lead][i][1] * NUM[i][1] +
                x[lead][i][2] * NUM[i][2] -
                y[lead][i][1] * DEN[i][1] -
                y[lead][i][2] * DEN[i][2];

        y[lead][i][0] /= DEN[i][0];

        y[lead][i][2]=y[lead][i][1]; y[lead][i][1]=y[lead][i][0];
        x[lead][i][2]=x[lead][i][1]; x[lead][i][1]=x[lead][i][0];

        x[lead][i+1][0] = y[lead][i][0];
    }
    if( x[lead][MWSPT_NSEC][0] > 32767)  x[lead][MWSPT_NSEC][0] = 32767;
    if( x[lead][MWSPT_NSEC][0] < -32768) x[lead][MWSPT_NSEC][0] = -32768;
    return  static_cast<int32_t>(x[lead][MWSPT_NSEC][0]);
#else
    double w = sample;
    for(int i=0; i < MWSPT_NSEC; i++) {
        x[lead][i][2] = x[lead][i][1];
        x[lead][i][1] = x[lead][i][0];
        x[lead][i][0] = w;
        w=0;
        y[lead][i][2] = y[lead][i][1];
        y[lead][i][1] = y[lead][i][0];
        for ( int j=0; j<NL[i]; j++ )
            w += NUM[i][j] * x[lead][i][j];
        for ( int j=1; j<DL[i]; j++ )
            w -= DEN[i][j] * y[lead][i][j];
        w /= DEN[i][0];
        y[lead][i][0] = w;
    }
    return static_cast<int32_t>(w);
#endif
}
#endif
