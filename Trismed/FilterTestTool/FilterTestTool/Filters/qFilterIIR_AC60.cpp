#include "qFilterIIR_AC60.h"

#ifdef USE_WINFILTER
qFilterIIR_AC60::qFilterIIR_AC60() :
    qAbstractFilter(0)
{

}

void qFilterIIR_AC60::InitLead(int lead)
{
    for(int i=0; i<NCoef+1; i++) {
        x[lead][i] = 0;
        x[lead][i] = 0;
        x[lead][i] = 0;
        y[lead][i] = 0;
        y[lead][i] = 0;
        y[lead][i] = 0;
    }
}

void qFilterIIR_AC60::privInit()
{
    memset(x, 0, sizeof(x));
    memset(y, 0, sizeof(y));
}

int32_t qFilterIIR_AC60::privFilter(int32_t sample, int lead)
{
    const double ACoef[NCoef+1] = {
        0.94963005757240915000,
        -2.76922072453381540000,
        3.91809454441488690000,
        -2.76922072453381540000,
        0.94963005757240915000
    };

    const double BCoef[NCoef+1] = {
        1.00000000000000000000,
        -2.89019558526045950000,
        4.05293022182029540000,
        -2.83928210781398690000,
        0.96508117383862690000
    };

    int n=0;
    //shift the old samples
    for(n=NCoef; n>0; n--) {
       x[lead][n] = x[lead][n-1];
       y[lead][n] = y[lead][n-1];
    }

    //Calculate the new output
    x[lead][0] = sample;
    y[lead][0] = ACoef[0] * x[lead][0];
    for(n=1; n<=NCoef; n++)
        y[lead][0] += ACoef[n] * x[lead][n] - BCoef[n] * y[lead][n];

    return y[lead][0];
}

#else
/*
 * Filter Coefficients (C Source) generated by the Filter Design and Analysis Tool
 * Generated by MATLAB(R) 9.5 and Signal Processing Toolbox 8.1.
 * Generated on: 11-Jan-2019 16:10:57
 */

/*
 * Discrete-Time IIR Filter (real)
 * -------------------------------
 * Filter Structure    : Direct-Form I, Second-Order Sections
 * Number of Sections  : 1
 * Stable              : Yes
 * Linear Phase        : No
 */

#ifdef USE_AC60_NOTCH_Q20_APASS1
#if 1
static const int NL[MWSPT_NSEC] = { 1,3,1 };
static const double NUM[MWSPT_NSEC][3] = {
    {
       0.9521017968695,                 0,                 0
    },
    {
                     1,   -1.459781021619,                 1
    },
    {
                     1,                 0,                 0
    }
};
static const int DL[MWSPT_NSEC] = { 1,3,1 };
static const double DEN[MWSPT_NSEC][3] = {
    {
                     1,                 0,                 0
    },
    {
                     1,   -1.389860133719,    0.904203593739
    },
    {
                     1,                 0,                 0
    }
};
#else
static const int NL[MWSPT_NSEC] = { 1,3,1 };
static const double NUM[MWSPT_NSEC][3] = {
  {
     0.9541072353784,                 0,                 0
  },
  {
                   1,   -1.457937254843,                 1
  },
  {
                   1,                 0,                 0
  }
};
static const int DL[MWSPT_NSEC] = { 1,3,1 };
static const double DEN[MWSPT_NSEC][3] = {
  {
                   1,                 0,                 0
  },
  {
                   1,   -1.391028483573,   0.9082144707567
  },
  {
                   1,                 0,                 0
  }
};
#endif
#else

static const int NL[MWSPT_NSEC] = { 1,3,1 };
static const double NUM[MWSPT_NSEC][3] = {
  {
      0.996812966709,                 0,                 0
  },
  {
                   1,   -1.457937254843,                 1
  },
  {
                   1,                 0,                 0
  }
};
static const int DL[MWSPT_NSEC] = { 1,3,1 };
static const double DEN[MWSPT_NSEC][3] = {
  {
                   1,                 0,                 0
  },
  {
                   1,   -1.453290760275,    0.993625933418
  },
  {
                   1,                 0,                 0
  }
};
#endif


qFilterIIR_AC60::qFilterIIR_AC60() :
    qAbstractFilter(0)
{

}

void qFilterIIR_AC60::InitLead(int lead)
{
    for(int i=0; i<MWSPT_NSEC; i++) {
        x[lead][i][0] = 0;
        x[lead][i][1] = 0;
        x[lead][i][2] = 0;
        y[lead][i][0] = 0;
        y[lead][i][1] = 0;
        y[lead][i][2] = 0;
    }
}

void qFilterIIR_AC60::privInit()
{
    memset(x, 0, sizeof(x));
    memset(y, 0, sizeof(y));
}

int32_t qFilterIIR_AC60::privFilter(int32_t sample, int lead)
{
#if 0
    uint16_t i;
    x[lead][0][0] = sample;
    for(i=0; i<MWSPT_NSEC; i++) {
        y[lead][i][0] =
                x[lead][i][0] * NUM[i][0] +
                x[lead][i][1] * NUM[i][1] +
                x[lead][i][2] * NUM[i][2] -
                y[lead][i][1] * DEN[i][1] -
                y[lead][i][2] * DEN[i][2];

        y[lead][i][0] /= DEN[i][0];

        y[lead][i][2]=y[lead][i][1]; y[lead][i][1]=y[lead][i][0];
        x[lead][i][2]=x[lead][i][1]; x[lead][i][1]=x[lead][i][0];

        x[lead][i+1][0] = y[lead][i][0];
    }
    if( x[lead][MWSPT_NSEC][0] > 32767)  x[lead][MWSPT_NSEC][0] = 32767;
    if( x[lead][MWSPT_NSEC][0] < -32768) x[lead][MWSPT_NSEC][0] = -32768;
    return  static_cast<int32_t>(x[lead][MWSPT_NSEC][0]);
#else
    double w = sample;
    for(int i=0; i < MWSPT_NSEC; i++) {
        x[lead][i][2] = x[lead][i][1];
        x[lead][i][1] = x[lead][i][0];
        x[lead][i][0] = w;
        w=0;
        y[lead][i][2] = y[lead][i][1];
        y[lead][i][1] = y[lead][i][0];
        for ( int j=0; j<NL[i]; j++ )
            w += NUM[i][j] * x[lead][i][j];
        for ( int j=1; j<DL[i]; j++ )
            w -= DEN[i][j] * y[lead][i][j];
        w /= DEN[i][0];
        y[lead][i][0] = w;
    }
    return static_cast<int32_t>(w);
#endif
}
#endif
