#include "qFilterIIR_HP005.h"

/*
 * Filter Coefficients (C Source) generated by the Filter Design and Analysis Tool
 * Generated by MATLAB(R) 9.5 and Signal Processing Toolbox 8.1.
 * Generated on: 04-Jan-2019 10:22:53
 */

/*
 * Discrete-Time IIR Filter (real)
 * -------------------------------
 * Filter Structure    : Direct-Form I, Second-Order Sections
 * Number of Sections  : 3
 * Stable              : Yes
 * Linear Phase        : No
 */

#ifndef USE_1ST_ORDER_IIR_ADS1298
#ifdef USE_BUTTERWORTH_0_05HZ_1ST_ORDER
static const int NL[MWSPT_NSEC] = { 1,2,1 };
static const double NUM[MWSPT_NSEC][2] = {
  {
     0.9996859393894,                 0
  },
  {
                   1,                -1
  },
  {
                   1,                 0
  }
};
static const int DL[MWSPT_NSEC] = { 1,2,1 };
static const double DEN[MWSPT_NSEC][2] = {
  {
                   1,                 0
  },
  {
                   1,  -0.9993718787787
  },
  {
                   1,                 0
  }
};
#else
const int NL[MWSPT_NSEC] = { 1,3,1,3,1,3,1 };
const double NUM[MWSPT_NSEC][3] = {
  {
     0.9998572875111,                 0,                 0
  },
  {
                   1,                -2,                 1
  },
  {
     0.9996103300311,                 0,                 0
  },
  {
                   1,                -2,                 1
  },
  {
     0.9994678046043,                 0,                 0
  },
  {
                   1,                -2,                 1
  },
  {
                   1,                 0,                 0
  }
};
const int DL[MWSPT_NSEC] = { 1,3,1,3,1,3,1 };
const double DEN[MWSPT_NSEC][3] = {
  {
                   1,                 0,                 0
  },
  {
                   1,   -1.999714423142,   0.9997147269025
  },
  {
                   1,                 0,                 0
  },
  {
                   1,   -1.999220508219,   0.9992208119048
  },
  {
                   1,                 0,                 0
  },
  {
                   1,   -1.998935457387,   0.9989357610296
  },
  {
                   1,                 0,                 0
  }
};
#endif
#endif /* USE_1ST_ORDER_IIR_ADS1298 */

qFilterIIR_HP005::qFilterIIR_HP005() :
    qAbstractFilter(0)
{
    privInit();
}

void qFilterIIR_HP005::InitLead(int lead)
{
#ifdef USE_1ST_ORDER_IIR_ADS1298
    x[lead] = 0;//value;
    y[lead] = 0.0;
#else
    for(int i=0; i<MWSPT_NSEC; i++) {
        x[lead][i][0] = 0;
        x[lead][i][1] = 0;
        x[lead][i][2] = 0;
        y[lead][i][0] = 0;
        y[lead][i][1] = 0;
        y[lead][i][2] = 0;
    }
#endif
}

void qFilterIIR_HP005::privInit()
{
#ifdef USE_1ST_ORDER_IIR_ADS1298
    for(int i=0; i<AMP_IN_LEADS; i++) {
        x[i] = 0.0;
        y[i] = 0.0;
//        wasOff[i] = SAMPLES_TO_STABLE;
    }
#else
    memset(x, 0, sizeof(x));
    memset(y, 0, sizeof(y));
#endif
}

int32_t qFilterIIR_HP005::privFilter(int32_t sample, int lead)
{
#if 0
    uint16_t i;
    x[lead][0][0] = sample;
    for(i=0; i<MWSPT_NSEC; i++) {
        y[lead][i][0] =
                x[lead][i][0] * NUM[i][0] +
                x[lead][i][1] * NUM[i][1] +
                x[lead][i][2] * NUM[i][2] -
                y[lead][i][1] * DEN[i][1] -
                y[lead][i][2] * DEN[i][2];

        y[lead][i][0] /= DEN[i][0];

        y[lead][i][2]=y[lead][i][1]; y[lead][i][1]=y[lead][i][0];
        x[lead][i][2]=x[lead][i][1]; x[lead][i][1]=x[lead][i][0];

        x[lead][i+1][0] = y[lead][i][0];
    }
    if( x[lead][MWSPT_NSEC][0] > 32767)  x[lead][MWSPT_NSEC][0] = 32767;
    if( x[lead][MWSPT_NSEC][0] < -32768) x[lead][MWSPT_NSEC][0] = -32768;
    return  static_cast<int32_t>(x[lead][MWSPT_NSEC][0]);
#else
#ifdef USE_1ST_ORDER_IIR_ADS1298
    static const float coeff = 0.99939;
    float tmpX = static_cast<float>(sample);
    float w = tmpX - x[lead] + coeff * y[lead];
    x[lead] = tmpX;
    y[lead] = w;
    return static_cast<int32_t>(w);
#else
    double w = sample;
    for(int i=0; i < MWSPT_NSEC; i++) {
        x[lead][i][2] = x[lead][i][1];
        x[lead][i][1] = x[lead][i][0];
        x[lead][i][0] = w;
        w=0;
        y[lead][i][2] = y[lead][i][1];
        y[lead][i][1] = y[lead][i][0];
        for ( int j=0; j<NL[i]; j++ )
            w += NUM[i][j] * x[lead][i][j];
        for ( int j=1; j<DL[i]; j++ )
            w -= DEN[i][j] * y[lead][i][j];
        w /= DEN[i][0];
        y[lead][i][0] = w;
    }
    return static_cast<int32_t>(w);
#endif
#endif
}
