/*
 * ST7735S_DRV.c
 *
 * Created: 9/22/2025 10:07:15 AM
 *  Author: tebun
 */ 

#include <asf.h>
#include "ST7735S_DRV.h"
#include "sam4s.h"

/* @cond 0 */
/**INDENT-OFF**/
#ifdef __cplusplus
extern "C" {
#endif

const char Font[] = {
	0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x5F, 0x00, 0x00,
	0x00, 0x07, 0x00, 0x07, 0x00,
	0x14, 0x7F, 0x14, 0x7F, 0x14,
	0x24, 0x2A, 0x7F, 0x2A, 0x12,
	0x23, 0x13, 0x08, 0x64, 0x62,
	0x36, 0x49, 0x56, 0x20, 0x50,
	0x00, 0x08, 0x07, 0x03, 0x00,
	0x00, 0x1C, 0x22, 0x41, 0x00,
	0x00, 0x41, 0x22, 0x1C, 0x00,
	0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
	0x08, 0x08, 0x3E, 0x08, 0x08,
	0x00, 0x80, 0x70, 0x30, 0x00,
	0x08, 0x08, 0x08, 0x08, 0x08,
	0x00, 0x00, 0x60, 0x60, 0x00,
	0x20, 0x10, 0x08, 0x04, 0x02,
	0x3E, 0x51, 0x49, 0x45, 0x3E,
	0x00, 0x42, 0x7F, 0x40, 0x00,
	0x72, 0x49, 0x49, 0x49, 0x46,
	0x21, 0x41, 0x49, 0x4D, 0x33,
	0x18, 0x14, 0x12, 0x7F, 0x10,
	0x27, 0x45, 0x45, 0x45, 0x39,
	0x3C, 0x4A, 0x49, 0x49, 0x31,
	0x41, 0x21, 0x11, 0x09, 0x07,
	0x36, 0x49, 0x49, 0x49, 0x36,
	0x46, 0x49, 0x49, 0x29, 0x1E,
	0x00, 0x00, 0x14, 0x00, 0x00,
	0x00, 0x40, 0x34, 0x00, 0x00,
	0x00, 0x08, 0x14, 0x22, 0x41,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x00, 0x41, 0x22, 0x14, 0x08,
	0x02, 0x01, 0x59, 0x09, 0x06,
	0x3E, 0x41, 0x5D, 0x59, 0x4E,
	0x7C, 0x12, 0x11, 0x12, 0x7C,
	0x7F, 0x49, 0x49, 0x49, 0x36,
	0x3E, 0x41, 0x41, 0x41, 0x22,
	0x7F, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x49, 0x49, 0x49, 0x41,
	0x7F, 0x09, 0x09, 0x09, 0x01,
	0x3E, 0x41, 0x41, 0x51, 0x73,
	0x7F, 0x08, 0x08, 0x08, 0x7F,
	0x00, 0x41, 0x7F, 0x41, 0x00,
	0x20, 0x40, 0x41, 0x3F, 0x01,
	0x7F, 0x08, 0x14, 0x22, 0x41,
	0x7F, 0x40, 0x40, 0x40, 0x40,
	0x7F, 0x02, 0x1C, 0x02, 0x7F,
	0x7F, 0x04, 0x08, 0x10, 0x7F,
	0x3E, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x09, 0x09, 0x09, 0x06,
	0x3E, 0x41, 0x51, 0x21, 0x5E,
	0x7F, 0x09, 0x19, 0x29, 0x46
};
const char Font2[] = {
	0x26, 0x49, 0x49, 0x49, 0x32,
	0x03, 0x01, 0x7F, 0x01, 0x03,
	0x3F, 0x40, 0x40, 0x40, 0x3F,
	0x1F, 0x20, 0x40, 0x20, 0x1F,
	0x3F, 0x40, 0x38, 0x40, 0x3F,
	0x63, 0x14, 0x08, 0x14, 0x63,
	0x03, 0x04, 0x78, 0x04, 0x03,
	0x61, 0x59, 0x49, 0x4D, 0x43,
	0x00, 0x7F, 0x41, 0x41, 0x41,
	0x02, 0x04, 0x08, 0x10, 0x20,
	0x00, 0x41, 0x41, 0x41, 0x7F,
	0x04, 0x02, 0x01, 0x02, 0x04,
	0x40, 0x40, 0x40, 0x40, 0x40,
	0x00, 0x03, 0x07, 0x08, 0x00,
	0x20, 0x54, 0x54, 0x78, 0x40,
	0x7F, 0x28, 0x44, 0x44, 0x38,
	0x38, 0x44, 0x44, 0x44, 0x28,
	0x38, 0x44, 0x44, 0x28, 0x7F,
	0x38, 0x54, 0x54, 0x54, 0x18,
	0x00, 0x08, 0x7E, 0x09, 0x02,
	0x18, 0xA4, 0xA4, 0x9C, 0x78,
	0x7F, 0x08, 0x04, 0x04, 0x78,
	0x00, 0x44, 0x7D, 0x40, 0x00,
	0x20, 0x40, 0x40, 0x3D, 0x00,
	0x7F, 0x10, 0x28, 0x44, 0x00,
	0x00, 0x41, 0x7F, 0x40, 0x00,
	0x7C, 0x04, 0x78, 0x04, 0x78,
	0x7C, 0x08, 0x04, 0x04, 0x78,
	0x38, 0x44, 0x44, 0x44, 0x38,
	0xFC, 0x18, 0x24, 0x24, 0x18,
	0x18, 0x24, 0x24, 0x18, 0xFC,
	0x7C, 0x08, 0x04, 0x04, 0x08,
	0x48, 0x54, 0x54, 0x54, 0x24,
	0x04, 0x04, 0x3F, 0x44, 0x24,
	0x3C, 0x40, 0x40, 0x20, 0x7C,
	0x1C, 0x20, 0x40, 0x20, 0x1C,
	0x3C, 0x40, 0x30, 0x40, 0x3C,
	0x44, 0x28, 0x10, 0x28, 0x44,
	0x4C, 0x90, 0x90, 0x90, 0x7C,
	0x44, 0x64, 0x54, 0x4C, 0x44,
	0x00, 0x08, 0x36, 0x41, 0x00,
	0x00, 0x00, 0x77, 0x00, 0x00,
	0x00, 0x41, 0x36, 0x08, 0x00,
	0x02, 0x01, 0x02, 0x04, 0x02
};

uint8_t wrap = 1; // TRUE
uint8_t colstart = 0, rowstart = 0, _tft_type;


void spiwrite(uint8_t spidata)
{
	#ifndef TFT_SPI_HARDWARE
		uint8_t ss;
		for(ss = 0x80; ss > 0; ss >>= 1) 
		{
			if (spidata & ss)
			{
				output_high(TFT_DATA);
			}
			else
			{
				output_low(TFT_DATA);
			}
			//delay_us(2);
			output_high(TFT_CLK);
			//delay_us(2);
			output_low(TFT_CLK);
			//delay_us(2);
		}
	#else
		usart_spi_write_single(USART_SERIAL, spidata);
	#endif
}

void write_command(uint8_t cmd_){
	output_low(TFT_DC);
	output_low(TFT_CS);
	spiwrite(cmd_);
	output_high(TFT_CS);
}

void write_data(uint8_t data_){
	output_high(TFT_DC);
	output_low(TFT_CS);
	spiwrite(data_);
	output_high(TFT_CS);
}

void TFT_InitA()
{
	write_command(0x11);
	delay_ms(10);
	write_command(0x3A);
	write_data(0x05);
	write_command(0x36);
	write_data(0x14);
	write_command(0x29);
}

void TFT_BlackTab_Initialize()
{
	output_high(TFT_CS);
	output_low(TFT_DC);
	
	#ifndef TFT_SPI_HARDWARE
	output_low(TFT_CLK);
	output_low(TFT_DATA);
	// output_drive(TFT_CLK);
	// output_drive(TFT_DATA);
	#endif
	
	Rcmd1();
	Rcmd2red();
	Rcmd3();
	write_command(ST7735_MADCTL);
	write_data(0xC0);
	_tft_type = 1;
}

void TFT_RedTab_Initialize()
{
	output_high(TFT_CS);
	output_low(TFT_DC);
	
	#ifndef TFT_SPI_HARDWARE
	output_low(TFT_CLK);
	output_low(TFT_DATA);
	// output_drive(TFT_CLK);
	// output_drive(TFT_DATA);
	#endif
	
	Rcmd1();
	Rcmd2red();
	Rcmd3();
	_tft_type = 0;
}

void drawPixel(uint8_t x, uint8_t y, uint16_t color)
{
	if((x >= _width) || (y >= _height))
	return;
	setAddrWindow(x,y,x+1,y+1);
	write_data(color >> 8);
	write_data(color & 0xFF);
}

void drawChar(uint8_t x, uint8_t y, uint8_t c, uint16_t color, uint16_t bg,  uint8_t size){
	int8_t i, j;
	if((x >= _width) || (y >= _height))
	return;
	if(size < 1) size = 1;
	if((c < ' ') || (c > '~'))
	c = '?';
	for(i=0; i<5; i++ ) {
		uint8_t line;
		if(c < 'S')
		line = Font[(c - 32)*5 + i];
		else
		line = Font2[(c - 'S')*5 + i];
		for(j=0; j<7; j++, line >>= 1) {
			if(line & 0x01) {
				if(size == 1) drawPixel(x+i, y+j, color);
				else          fillRect(x+(i*size), y+(j*size), size, size, color);
			}
			else if(bg != color) {
				if(size == 1) drawPixel(x+i, y+j, bg);
				else          fillRect(x+i*size, y+j*size, size, size, bg);
			}
		}
	}
}

void drawtext(uint8_t x, uint8_t y, char *_text, uint16_t color, uint16_t bg, uint8_t size)
{
	uint8_t cursor_x, cursor_y;
	uint16_t textsize, i;
	cursor_x = x, cursor_y = y;
	textsize = strlen(_text);
	for(i = 0; i < textsize; i++)
	{
		if(wrap && ((cursor_x + size * 5) > _width))
		{
			cursor_x = 0;
			cursor_y = cursor_y + size * 7 + 3 ;
			if(cursor_y > _height) cursor_y = _height;
			if(_text[i] == 0x20) goto _skip; 
		}
		drawChar(cursor_x, cursor_y, _text[i], color, bg, size);
		cursor_x = cursor_x + size * 6;
		if(cursor_x > _width) cursor_x = _width;
		_skip:;
	}
}

void fillRectangle(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint16_t color){
	uint8_t hi, lo;
	if((x >= _width) || (y >= _height))
	return;
	if((x + w - 1) >= _width)
	w = _width  - x;
	if((y + h - 1) >= _height)
	h = _height - y;
	setAddrWindow(x, y, x+w-1, y+h-1);
	hi = color >> 8; lo = color;
	output_high(TFT_DC);
	output_low(TFT_CS);
	for(y=h; y>0; y--) {
		for(x = w; x > 0; x--) {
			spiwrite(hi);
			spiwrite(lo);
		}
	}
	output_high(TFT_CS);
}

void fillScreen(uint16_t color) {
	fillRectangle(0, 0, _width, _height, color);
}

void fillRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint16_t color) {
	uint16_t i;
	// Update in subclasses if desired!
	for (i = x; i < x + w; i++) {
		drawFastVLine(i, y, h, color);
	}
}

void drawFastVLine(uint8_t x, uint8_t y, uint8_t h, uint16_t color)
{
	uint8_t hi, lo;
	if((x >= _width) || (y >= _height))
	return;
	if((y + h - 1) >= _height)
	h = _height - y;
	hi = color >> 8; lo = color;
	setAddrWindow(x, y, x, y + h - 1);
	output_high(TFT_DC);
	//output_low(tft_cs);
	while (h--) {
		spiwrite(hi);
		spiwrite(lo);
	}
	//output_high(tft_cs);
}

void setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1){
	write_command(ST7735_CASET);
	write_data(0);
	write_data(x0 + colstart);
	write_data(0);
	write_data(x1 + colstart);
	write_command(ST7735_RASET);
	write_data(0);
	write_data(y0 + rowstart);
	write_data(0);
	write_data(y1 + rowstart);
	write_command(ST7735_RAMWR); // Write to RAM
}

void Rcmd2red(){
	write_command(ST7735_CASET);
	write_data(0x00); write_data(0x00);
	write_data(0x00); write_data(0x7F);
	write_command(ST7735_RASET);
	write_data(0x00); write_data(0x00);
	write_data(0x00); write_data(0x9F);
}

void Rcmd3(){
	write_command(ST7735_GMCTRP1);
	write_data(0x02); write_data(0x1C); write_data(0x07); write_data(0x12);
	write_data(0x37); write_data(0x32); write_data(0x29); write_data(0x2D);
	write_data(0x29); write_data(0x25); write_data(0x2B); write_data(0x39);
	write_data(0x00); write_data(0x01); write_data(0x03); write_data(0x10);
	write_command(ST7735_GMCTRN1);
	write_data(0x03); write_data(0x1D); write_data(0x07); write_data(0x06);
	write_data(0x2E); write_data(0x2C); write_data(0x29); write_data(0x2D);
	write_data(0x2E); write_data(0x2E); write_data(0x37); write_data(0x3F);
	write_data(0x00); write_data(0x00); write_data(0x02); write_data(0x10);
	write_command(ST7735_NORON);
	delay_ms(10);
	write_command(ST7735_DISPON);
	delay_ms(100);
}

void Rcmd1(){
	write_command(ST7735_SWRESET);
	delay_ms(150);
	write_command(ST7735_SLPOUT);
	delay_ms(500);
	write_command(ST7735_FRMCTR1);
	write_data(0x01);
	write_data(0x2C);
	write_data(0x2D);
	write_command(ST7735_FRMCTR2);
	write_data(0x01);
	write_data(0x2C);
	write_data(0x2D);
	write_command(ST7735_FRMCTR3);
	write_data(0x01); write_data(0x2C); write_data(0x2D);
	write_data(0x01); write_data(0x2C); write_data(0x2D);
	write_command(ST7735_INVCTR);
	write_data(0x07);
	write_command(ST7735_PWCTR1);
	write_data(0xA2);
	write_data(0x02);
	write_data(0x84);
	write_command(ST7735_PWCTR2);
	write_data(0xC5);
	write_command(ST7735_PWCTR3);
	write_data(0x0A);
	write_data(0x00);
	write_command(ST7735_PWCTR4);
	write_data(0x8A);
	write_data(0x2A);
	write_command(ST7735_PWCTR5);
	write_data(0x8A);
	write_data(0xEE);
	write_command(ST7735_VMCTR1);
	write_data(0x0E);
	write_command(ST7735_INVOFF);
	write_command(ST7735_MADCTL);
	write_data(0xC8);
	write_command(ST7735_COLMOD);
	write_data(0x05);
}


#ifdef __cplusplus
}
#endif